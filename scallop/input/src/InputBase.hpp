/*	This file InputBase.hpp is part of scallop.
 *
 *  scallop is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  scallop is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with scallop.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Created on: Nov 15, 2014
 *      Author: Andreas Linscheid
 */

#include "scallop/input/InputBase.h"
#include "scallop/error_handling/Error.h"
#include "scallop/output/TextFile.h"
#include <typeinfo>
#include <type_traits>
#include <string>

namespace scallop {
namespace input {

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,T const& defaultValue,T &value) const{
	std::vector<T> oneElement;
	std::vector<T> onedefaultValueElement(1,defaultValue);
	this->get_option(valueString,onedefaultValueElement,oneElement);
	value = oneElement.front();
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,T &value) const {
	if ( valueString.empty() )
		error_handling::Error("No default value, but also noting to covert into a value.",1);
	//we don't care what the default is, since from this point valueString is either successfully parsed or
	//	the input fails.
	this->get_option(valueString,value,value);
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,std::vector<T> const& defaultValue,std::vector<T> &values) const {
	if ( valueString.empty() ){
		values = defaultValue;
	} else {
		std::stringstream ss(valueString);
		if ( std::is_same<typename std::remove_cv<T>::type ,bool>::value )
			ss >> std::boolalpha;
		T element;
		while ( not (ss.tellg() == -1 or ss.tellg() == valueString.size() ) ){
			ss >> element;
			std::string nameOfType = typeid(element).name();
			if ( ss.fail() )
				error_handling::Error( std::string("Failed to parse the value string ")
					+ valueString + " as " + nameOfType, 1 );

			values.push_back(element);
		};
	}
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,std::vector<T> &values) const {
	if ( valueString.empty() )
		error_handling::Error("No default value, but also nothing to covert into a value.",1);
	this->get_option(valueString,values,values);
}

template<class derived>
void InputBase<derived>::build_input_manual(std::string const& fileName) const {
	std::string textUserManualString = "This manual was automatically generated by the scallop project.\n"
			"DO NOT EDIT THIS FILE ALL CHANGES WILL BE LOST!\n";
	textUserManualString += _manual;

	output::TextFile manualFile;
	manualFile.write(fileName,textUserManualString);
}

template<class derived>
void InputBase<derived>::add_option_to_manual(std::string const& textWithOptionDescription) {
	_manual += textWithOptionDescription;
}

template<class derived>
void InputBase<derived>::parse_variables(InputFile const& inputFile) {
	for ( size_t i = 0 ; i < _mebrFctnPtrToVariableParsing.size(); ++i) {
		 (static_cast<derived*>(this)->*_mebrFctnPtrToVariableParsing[i])(inputFile);
	}
	_isInit = true;
}

template<class derived>
void InputBase<derived>::register_variable_parsing( void(derived::* function )(InputFile const&) ) {
	_mebrFctnPtrToVariableParsing.push_back(function);
}
} /* namespace input */
} /* namespace scallop */
