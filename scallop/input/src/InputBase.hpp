/*	This file InputBase.hpp is part of scallop.
 *
 *  scallop is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  scallop is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with scallop.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Created on: Nov 15, 2014
 *      Author: Andreas Linscheid
 */

#include "scallop/input/InputBase.h"
#include "scallop/error_handling/Error.h"
#include "scallop/output/TextFile.h"
#include <typeinfo>

namespace scallop {
namespace input {

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,T const& defaultValue,T &value) const{
	std::vector<T> oneElement;
	std::vector<T> onedefaultValueElement(1,defaultValue);
	this->get_option(valueString,onedefaultValueElement,oneElement);
	value = oneElement.front();
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,T &value) const {
	if ( valueString.empty() )
		error_handling::Error("No default value, but also noting to covert into a value.",1);
	//we don't care what the default is, since from this point valueString is either successfully parsed or
	//	the input fails.
	this->get_option(valueString,value,value);
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,std::vector<T> const& defaultValue,std::vector<T> &values) const {
	if ( valueString.empty() ){
		values = defaultValue;
	} else {
		std::stringstream ss(valueString);
		T element;
		do{
			ss >> element;
			if ( ss.rdstate() & std::stringstream::failbit )
				error_handling::Error( std::string("Failed to parse the value string ")
					+ valueString + " as " + typeid(element).name(), 1 );
			values.push_back(element);
		} while ( ss.rdstate() & std::stringstream::eofbit);
	}
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,std::vector<T> &values) const {
	if ( valueString.empty() )
		error_handling::Error("No default value, but also nothing to covert into a value.",1);
	this->get_option(valueString,values,values);
}

//
//template<class derived>
//void InputBase<derived>::get_option(
//		std::string const& valueString,
//		std::vector<bool> const& defaultValue,
//		std::vector<bool> &values) const {
//	if ( valueString.empty() ){
//		values = defaultValue;
//	} else {
//		std::stringstream ss(valueString);
//		bool element;
//		do{
//			ss >> std::boolalpha >> element;
//			if ( ss.rdstate() & std::stringstream::failbit )
//				error_handling::Error( std::string("Failed to parse the value string ")
//					+ valueString + " as bool", 1 );
//			values.push_back(element);
//		} while ( ss.rdstate() & std::stringstream::eofbit);
//	}
//}

template<class derived>
void InputBase<derived>::build_input_manual(std::string const& fileName) const {
	std::string textUserManualString = "This manual was automatically generated by the scallop project.\n"
			"DO NOT EDIT THIS FILE ALL CHANGES WILL BE LOST!\n";
	textUserManualString += _manual;

	output::TextFile manualFile;
	manualFile.write(fileName,textUserManualString);
}

template<class derived>
void InputBase<derived>::add_option_to_manual(std::string const& textWithOptionDescription) {
	_manual += textWithOptionDescription;
}

template<class derived>
void InputBase<derived>::parse_all_registered_variables(InputFile const& inputFile) {
	for ( size_t i = 0 ; i < _mebrFctnPtrToVariableParsing.size(); ++i) {
		 (static_cast<derived*>(this)->*_mebrFctnPtrToVariableParsing[i])(inputFile);
	}
//	for ( auto & inputVariableReadingFunction : _mebrFctnPtrToVariableParsing ) {
//	 (inputVariableReadingFunction*)(inputFile);
//	}
}

template<class derived>
void InputBase<derived>::register_variable_parsing( void(derived::* function )(InputFile const&) ) {
	_mebrFctnPtrToVariableParsing.push_back(function);
}
} /* namespace input */
} /* namespace scallop */
